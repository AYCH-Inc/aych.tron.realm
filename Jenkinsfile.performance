#!groovy

def setBuildName(newBuildName) {
  currentBuild.displayName = "${currentBuild.displayName} - ${newBuildName}"
}

def getSourceArchive() {
  checkout scm
  sh 'git clean -ffdx -e .????????'
  sh 'git submodule update --init'
}

def buildDockerEnv(name) {
  docker.withRegistry("https://${env.DOCKER_REGISTRY}", "ecr:eu-west-1:aws-ci-user") {
    sh "./packaging/docker_build.sh $name ."
  }

  return docker.image(name)
}

def readGitTag() {
  sh "git describe --exact-match --tags HEAD | tail -n 1 > tag.txt 2>&1 || true"
  def tag = readFile('tag.txt').trim()
  return tag
}

def readGitSha() {
  sh "git rev-parse HEAD | cut -b1-8 > sha.txt"
  def sha = readFile('sha.txt').readLines().last().trim()
  return sha
}

stage('Test Performance') {
  // Select docker-cph-X.  We want docker, metal (brix) and only one executor
  // (exclusive)
  node('docker && brix && exclusive') {
    getSourceArchive()

    def gitTag = readGitTag()
    def gitSha = readGitSha()

    if (gitTag == "") {
      setBuildName(gitSha)
    } else {
      setBuildName("Tag ${gitTag}")
    }

    def buildEnv = buildDockerEnv('ci/realm-core:snapshot')
    buildEnv.inside {
      // FIXME: get cache of persisted (as in forever) results "core-benchmarks.zip" and unzip to $(pwd)/core-benchmarks
      sh 'cd test/bench && mkdir -p core-benchmarks && REALM_BENCH_DIR="$(pwd)/core-benchmarks" ./gen_bench-hist.sh'
      sh 'cd test/bench && mkdir -p results && ./parse_bench_hist.py --local-html results/ core-benchmarks/' // requires matplotlib 1.3.1
      // FIXME: zip core-benchmarks to core-benchmarks.zip and overwrite persisted version for next time
      // FIXME: save "results" directory (for the lifetime of this build) and link to "results/report.html" from github
    }
  }
}
