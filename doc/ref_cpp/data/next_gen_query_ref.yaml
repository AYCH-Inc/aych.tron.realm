#
# C++ reference documentation for the Next-generation syntax.
#

ID         : class_next_gen_query
TITLE      : Next-Generation Query Syntax
SUMMARY    : none
DESCR      : >
            <p>This syntax is <b>experimental and must be considered unstable</b>. It lets you write expressions like:</p>
            <tt>&nbsp;&nbsp;&nbsp;Query q = books.column().pages >= 200 && books.column().author == "Griffiths";
            <br>
            &nbsp;&nbsp;&nbsp;size_t match = q.find();
            </tt>
            
            <p>If books is a <em>dynamic </em>table you need to specify column types as template arguments and 
            give their column number in parentheses:</p>
            
            <tt>&nbsp;&nbsp;&nbsp;Query q = books.column<Int>(0) >= 200 && books.column<String>(1).author == "Griffiths";
            <br>&nbsp;&nbsp;&nbsp;size_t match = q.find();         
            </tt>
            <p>Queries can only perform simple searches on a single table - all 
            columns must belong to the same table and joins or self joins are not supported. </p>
            <div>
            <table class="table table-bordered" border="1">
            <thead><tr><td colspan="2"><h3> <span lang="da">Relevant classes</span></h3>
            </td>
            </tr>
            </thead>
            <tbody>
            <tr><td>{@link class_dyn_query}
            </td>
            <td>Returned by compare operators, logical operators and parantheses. 
            You can perform methods like <code>find()</code>, <code>find_all()</code>, <code>maximum()</code>, etc, 
            on <span lang="da">it</span>.</td>
            </tr>
            <tr><td valign="top"><tt>
            
            <span lang="da">Columns&lt;<em>T</em>&gt;</span></tt></td>
            <td>Returned by <code>table.column().<em>name</em>
            </a></code> for typed tables and <code>table.column&lt;T&gt;(<em>column 
            number</em>)</code> for untyped tables. <br />
            <br />
            You can declare freestanding column objects from both typed and untyped 
            tables<span lang="da">. Specify the type T that matches the column type:</span><br />
            <br />
            <tt>&nbsp;&nbsp;&nbsp;Columns&lt;Int&gt; <span lang="da">pages</span> = typed.column().<span lang="da">pages</span>;<br />
            &nbsp;&nbsp;&nbsp;Columns&lt;<span lang="da">String</span>&gt; <span lang="da">author</span> = untyped.column&lt;<span lang="da">String</span>&gt;(2);<br />
            </tt><br />
            <span lang="da">These free standing column objects have no methods 
            available and are only meant to be used as shorthand references in queries.</span></td>
            </tr>
            </tbody>
            </table>
            </div>
            <div>
            <table class="table table-bordered" border="1">
            <thead><tr><td colspan="6"><h3> <span lang="da">Column types</span></h3>
            </td>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td colspan="6"><span lang="da">Not all column types are currently 
            supported. Supported types are:</span></td>
            </tr>
            <tr><td><span lang="da">Int</span></td>
            <td><span lang="da">Bool</span></td>
            <td><span lang="da">String</span></td>
            <td><span lang="da">Float</span></td>
            <td><span lang="da">Double</span></td>
            <td><span lang="da">Date</span></td>
            </tr>
            </tbody>
            </table>
            <table class="table table-bordered" border="1">
            <thead><tr><td><h3> <span lang="da">Compare operator</span></h3>
            </td>
            <td>
            <h3><span lang="da">Return type</span></h3>
            </td>
            <td>
            <h3><span lang="da">Remarks</span></h3>
            </td>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td><span lang="da">==</span></td>
            <td><span lang="da">Query</span></td>
            <td>&nbsp;</td>
            </tr>
            <tr>
            <td><span lang="da">!=</span></td>
            <td><span lang="da">Query</span></td>
            <td>&nbsp;</td>
            </tr>
            <tr>
            <td><span lang="da">&gt;</span></td>
            <td><span lang="da">Query</span></td>
            <td><span lang="da">Strings not supported</span></td>
            </tr>
            <tr>
            <td><span lang="da">&lt;</span></td>
            <td><span lang="da">Query</span></td>
            <td><span lang="da">Strings not supported</span></td>
            </tr>
            <tr>
            <td><span lang="da">&gt;=</span></td>
            <td><span lang="da">Query</span></td>
            <td><span lang="da">Strings not supported</span></td>
            </tr>
            <tr><td><span lang="da">&lt;=</span></td>
            <td><span lang="da">Query</span></td>
            <td><span lang="da">Strings not supported</span></td>
            </tr>
            </tbody>
            </table>
            <table class="table table-bordered" border="1">
            <thead><tr><td colspan="4"><h3> <span lang="da">Arithmetic operators</span></h3>
            </td>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td colspan="4"><span lang="da">Arithmetic operators only apply to 
            columns of type Int, Float and Double. Currently four operators are 
            available (more will be introduced in future releases):</span></td>
            </tr>
            <tr><td><span lang="da">+ (plus)</span></td>
            <td><span lang="da">- (minus)</span></td>
            <td><span lang="da">* (multiply)</span></td>
            <td><span lang="da">/ (division)</span></td>
            </tr>
            </tbody>
            </table>

            <table class="table table-bordered" border="1" style="width: 100%">
            <thead><tr>
            <td style="width: 285px">
            <h3>Logical operators and parantheses</h3>
            </td>
            <td>
            <h3><strong>Return type</strong></h3>
            </td>
            </tr>
            </thead>
            <tr>
            <td style="width: 285px">Query || Query</td>
            <td>Query</td>
            </tr>
            <tr>
            <td style="width: 285px">Query &amp;&amp; Query</td>
            <td>Query</td>
            </tr>
            <tr>
            <td style="width: 285px">(Query)</td>
            <td>Query</td>
            </tr>
            </table>


            
            
            <h3>Type conversion/promotion</h3>
                
            <p>If the operands of a compare or arithmetic operator 
            are of different types, then conversion/promotion mimicks that of the C++ 
            standard. Take following example:</p>

            <tt>&nbsp;&nbsp;&nbsp;table.columns().float_column + 123 > table.columns().double_column;</tt>

            <p>This behaves like when type casting as follows:</p>

            <tt>&nbsp;&nbsp;&nbsp;double(table.columns().float_column + float(123)) > table.columns().double_column;</tt>

            <p>As for regular C++ expressions, be aware of caveats. For example 
            <tt>float(100000005) == 100000008</tt> because of the gap between values that can be 
            represented by a float. This can lead to errorneous arithmetic and comparisons.</p>
EXAMPLES:                          # Optional
- CODE     : ex_cpp_ng_query_typed
  DESCR    : Typed table
- CODE     : ex_cpp_ng_query_untyped
  DESCR    : Untyped table
CATEGORIES:
- none:
  METHODS:
  #-------------------------------
  - g_method_will_be_made_later:
      TODO     : later            # Method is marked for later implementation