


class RowList;

Semantically: a collection of Row objects (though the implementation will be different)

Purpose: The RowList class serves dual purposes
1) It provides a "transport" of (many) row references between SharedGroups,
   without being linked to queries
2) It provides a basic collection suitable for classical emperative manipulation
   of row references.


Basic operation
---------------

obtained from a TableView by calling
 - TableView::move_row_list(RowList&);
 - this is a *move* operation, so the TableView no longer holds valid data.
 - this can be made transparent, though, as the TableView can regenerate data on demand
   by rerunning its query
 - alternative: obtain directly from a query, instead of going through a tableview.

lookups in RowList gives you a RowExpr:
 - RowExpr RowList::get(index)
 - The RowExpr can then be changed to a proper Row accessor and used, similar to obtaining
   a row accessor from a table.


Handover
--------

supports handover between shared groups looking at *same* version.
Handover involves exporting on the producing thread, then importing
on the consuming thread. Import will fail if the importing SharedGroup
is locked to a different version of the database than the exporting one.

During handover, the RowList is represented by a different type: FreeStandingRowList,
which does not support access to its members.

- SharedGroup::export(RowList&, FreeStandingRowList&)
- SharedGroup::import(FreeStandingRowList&, RowList&)

Both import() and export() has move semantics, so after exporting the originating
RowList is empty, and after importing the FreeStandingRowList cannot be imported
again but must be discarded (or reused as a target for another export).



Implicit accessor updates
-------------------------

The semantics for implicit accessor updates simply mirror the semantics for our
existing row accessors:

If an entry in the table referenced from the RowList is removed, the reference is
detached.

This can be checked:
 - bool RowList::is_entry_attached(index)
 - note that the reference is not removed from the RowList. It is just detached.
 - this is an enabler for iterating over the RowList, see below.

If a table entry referenced from the rowList is moved, the matching reference in the
RowList is transparently updated.

Rows obtained by RowList::get(index) on a detached entry will themselves be detached.


Explicit modification
---------------------

This supports working imperatively with RowLists. It will allow checked/safe iterators
for use in imperative algorithms, which is currently not practical with TableViews.

- RowList::remove(index)
- RowList::set(index, Row)
- RowList::insert(index, Row)

In addition, explicit updates to the underlying table of a RowList has effect on the
RowList as described under "implicit accessor updates".

We will most likely add methods which change both the RowList *and* the underlying table
in a consistent manner (for performance reasons).



Alternatives to adding a new class for this
===========================================


Alternative: Adding the described semantics to TableView

This will be in the form of TableView having two modes: 
 - reflective (this is what we have now: always *reflect* the query it is based on)
 - imperative (this is the semantics described for RowList above)

Pro: we can alredy run queries on TableViews. Work is needed to support queries with RowLists

Con: mixing TableViews in different modes may yield something that is really hard to understand.

Con: requires us to implement handover of the query, not just the data. This adds complexity,
     and it is not clear if we will ever want to reuse the query on the foreground thread... 
     After all, the querying is moved to the background thread specifically to *avoid* running 
     it on the foreground thread.


Later Option: Re-implementing TableViews using RowList

A table view will then use the RowList internally to hold its references.
This has an interesting consequence:

Our current implementation of TableViews will require query rerun whenever the underlying
table is changed in any way, including removals and moving of elements.

An implementation of TableViews based on RowList will *not* need to rerun the query
in response to removals and moving of elements. I don't know if that is important or not.



Iteration over a RowList

case A:

RowList rl = query(....)
for e in rl:
    advance_read()  <------ assume this deletes an entry in the table referenced by rl
    <<< .. do something with e >>

There are multiple ways this can be made to work:

1) directly remove the reference from the RowList
2) nullify the reference in the RowList

re 1) The rowlist reflects a sort order, so we cannot use move_last_over on the reference table,
      but must instead move all entries at a higher index one down. This puts the cost of deleting
      all entries at O(n*n) - further: the iterator must be modified to keep it pointing to the
      correct reference.

re 2) Simply set the reference to null. The iterator may have to skip ahead over any null entries
      when it moves, but for the common case of iterating forward through the entire set, this is 
      limited to a total O(n), so the cost of deleting all entries iteratively is just O(n).


Observation: We may have 'e' pointing to the very last reference, when it is removed by advance_read. 
In that case, there is no valid successor value, so it is just not possible to have a valid iterator 
after advance_read(). Consequently, We *have* to support checking of the iterator, when iteration and 
advance_read() are interleaved inside the loop:

case B:

RowList rl = query(....)
for e in rl:
    advance_read()  <------ assume this deletes an entry in the table referenced by rl
    if (e.is_valid()) {
         <<< .. do something with e >>
    }

and we must also support detection of the use of an invalid iterator (for the case where users forget
to check is_valid()). Such usage should throw.

