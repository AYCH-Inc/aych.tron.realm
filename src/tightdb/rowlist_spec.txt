


class RowList;

Semantically: a collection of Row objects (though the implementation will be different)

Purpose: The RowList class serves dual purposes
1) It provides a "transport" of (many) row references between SharedGroups,
   without being linked to queries
2) It provides a basic collection suitable for classical emperative manipulation
   of row references.


Basic operation
---------------

obtained from a TableView by calling
 - TableView::move_row_list(RowList&);
 - this is a *move* operation, so the TableView no longer holds valid data.
 - this can be made transparent, though, as the TableView can regenerate data on demand
   by rerunning its query
 - alternative: obtain directly from a query, instead of going through a tableview.

lookups in RowList gives you a RowExpr:
 - RowExpr RowList::get(index)
 - The RowExpr can then be changed to a proper Row accessor and used, similar to obtaining
   a row accessor from a table.


Handover
--------

supports handover between shared groups looking at *same* version.
Handover involves exporting on the producing thread, then importing
on the consuming thread. Import will fail if the importing SharedGroup
is locked to a different version of the database than the exporting one.

During handover, the RowList is represented by a different type: FreeStandingRowList,
which does not support access to its members.

- SharedGroup::export(RowList&, FreeStandingRowList&)
- SharedGroup::import(FreeStandingRowList&, RowList&)

Both import() and export() has move semantics, so after exporting the originating
RowList is empty, and after importing the FreeStandingRowList cannot be imported
again but must be discarded (or reused as a target for another export).



Implicit accessor updates
-------------------------

The semantics for implicit accessor updates simply mirror the semantics for our
existing row accessors:

If an entry in the table referenced from the RowList is removed, the reference is
detached.

This can be checked:
 - bool RowList::is_entry_attached(index)
 - note that the reference is not removed from the RowList. It is just detached.
 - this is an enabler for iterating over the RowList.

If a table entry referenced from the rowList is moved, the matching reference in the
RowList is transparently updated.

Rows obtained by RowList::get(index) on a detached entry will themselves be detached.


Explicit modification
---------------------

This supports working imperatively with RowLists. It will allow checked/safe iterators
for use in imperative algorithms, which is currently not practical with TableViews.

- RowList::remove(index)
- RowList::set(index, Row)
- RowList::insert(index, Row)

In addition, explicit updates to the underlying table of a RowList has effect on the
RowList as described under "implicit accessor updates".

We will most likely add methods which change both the RowList *and* the underlying table
in a consistent manner (for performance reasons).



Alternatives to adding a new class for this
===========================================


Alternative: Adding the described semantics to TableView

This will be in the form of TableView having two modes: 
 - reflective (this is what we have now: always *reflect* the query it is based on)
 - imperative (this is the semantics described for RowList above)

Pro: we can alredy run queries on TableViews. Work is needed to support queries with RowLists

Con: mixing TableViews in different modes may yield something that is really hard to understand.

Con: requires us to implement handover of the query, not just the data. This adds complexity,
     and it is not clear if we will ever want to reuse the query on the foreground thread... 
     After all, the querying is moved to the background thread specifically to *avoid* running 
     it on the foreground thread.


Later Option: Re-implementing TableViews using RowList

A table view will then use the RowList internally to hold its references.
This has an interesting consequence:

Our current implementation of TableViews will require query rerun whenever the underlying
table is changed in any way, including removals and moving of elements.

An implementation of TableViews based on RowList will *not* need to rerun the query
in response to removals and moving of elements. I don't know if that is important or not.
